#!/bin/bash

# Main script to create and manage QEMU virtual machines

set -eo pipefail # Exit on error, treat unset variables as an error, and propagate pipeline errors

# --- Configuration ---
PROJECT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ISO_PATH="${PROJECT_DIR}/iso/ubuntu-desktop.iso" # User must place Ubuntu Desktop ISO here
VPN_CONFIG_DIR="${PROJECT_DIR}/vpn"
VM_CONFIGS_DIR="${PROJECT_DIR}/vm_configs"
VM_DISKS_DIR="${PROJECT_DIR}/vm_disks"
SCRIPTS_DIR="${PROJECT_DIR}/scripts"
OUTPUT_DIR="${PROJECT_DIR}/output"
VM_INFO_FILE="${OUTPUT_DIR}/vm_info.txt"
PRESEED_FILE="${SCRIPTS_DIR}/preseed.cfg"
GUEST_SETUP_SCRIPT_NAME="setup_vm_in_guest.sh" # Name of the script in SCRIPTS_DIR

NUM_VMS=10 # Should match the number of configs generated by generate_vm_configs.py

# Temporary HTTP server settings
HOST_IP_FOR_GUEST="10.0.2.2" # Default QEMU user-mode network gateway for host
HTTP_SERVER_PORT_BASE=8000 # Base port for temp HTTP server, will increment per VM if run in parallel (not current design)
TEMP_SERVE_DIR_BASE="/tmp/qemu_http_serve" # Base for temp content

# --- Helper Functions ---
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
}

check_dependencies() {
    log "Checking dependencies..."
    local missing_deps=0
    for cmd in qemu-system-x86_64 qemu-img python3 cpulimit mkpasswd; do
        if ! command -v "$cmd" &> /dev/null; then
            log "Error: Required command '$cmd' not found."
            missing_deps=1
        fi
    done
    if [ "$missing_deps" -eq 1 ]; then
        log "Please install missing dependencies and try again."
        exit 1
    fi
    log "All dependencies found."
}

check_project_files() {
    log "Checking project files..."
    if [ ! -f "$ISO_PATH" ]; then
        log "Error: Ubuntu ISO not found at $ISO_PATH"
        log "Please download an Ubuntu Desktop ISO (e.g., 22.04, 24.04) and place it there."
        exit 1
    fi
    log "Ubuntu ISO found."

    if [ ! -f "$PRESEED_FILE" ]; then
        log "Error: Preseed file not found at $PRESEED_FILE"
        exit 1
    fi
    log "Preseed file found."

    if [ ! -f "${SCRIPTS_DIR}/${GUEST_SETUP_SCRIPT_NAME}" ]; then
        log "Error: Guest setup script not found at ${SCRIPTS_DIR}/${GUEST_SETUP_SCRIPT_NAME}"
        exit 1
    fi
    log "Guest setup script found."

    for i in $(seq 1 "$NUM_VMS"); do
        if [ ! -f "${VPN_CONFIG_DIR}/vpn-${i}.ovpn" ]; then
            log "Error: VPN config file ${VPN_CONFIG_DIR}/vpn-${i}.ovpn not found."
            exit 1
        fi
    done
    log "All VPN configuration files found."
}

# --- Main Logic ---
main() {
    log "Starting QEMU VM Manager script."

    check_dependencies
    check_project_files

    mkdir -p "$VM_CONFIGS_DIR" "$VM_DISKS_DIR" "$OUTPUT_DIR"

    log "Generating VM configurations..."
    if ! (cd "$PROJECT_DIR" && python3 "${SCRIPTS_DIR}/generate_vm_configs.py"); then
        log "Error: Failed to generate VM configurations. Exiting."
        exit 1
    fi
    log "VM configurations generated/updated successfully."

    # Clear previous vm_info.txt or create it with a header
    echo "# VM Information (Generated on $(date))" > "$VM_INFO_FILE"
    echo "# VM_Name, MAC_Address, VNC_Port_Host, VNC_Password, UUID, BIOS_Serial" >> "$VM_INFO_FILE"

    for i in $(seq 1 "$NUM_VMS"); do
        local vm_config_file="${VM_CONFIGS_DIR}/vm-${i}.json"
        if [ ! -f "$vm_config_file" ]; then
            log "Error: VM config file $vm_config_file not found. Skipping VM $i."
            continue
        fi

        log "Processing VM $i from $vm_config_file..."

        # Extract details from JSON config
        local vm_name=$(jq -r '.vm_name' "$vm_config_file")
        local mac_address=$(jq -r '.mac_address' "$vm_config_file")
        local vnc_port_host=$(jq -r '.vnc_port_host' "$vm_config_file")
        local vnc_password=$(jq -r '.vnc_password' "$vm_config_file")
        local vm_uuid=$(jq -r '.uuid' "$vm_config_file")
        local bios_serial=$(jq -r '.bios_serial' "$vm_config_file")
        local cpu_model=$(jq -r '.cpu_model' "$vm_config_file")
        local ram_mb=$(jq -r '.ram_size_mb' "$vm_config_file")
        local disk_size_gb=$(jq -r '.disk_size_gb' "$vm_config_file")
        local openvpn_config_file=$(jq -r '.openvpn_config_file' "$vm_config_file") # e.g., vpn-1.ovpn
        local vm_id=$(jq -r '.vm_id' "$vm_config_file")

        local disk_image_path="${VM_DISKS_DIR}/${vm_name}.qcow2"
        local current_http_port=$((HTTP_SERVER_PORT_BASE + i - 1)) # Unique port per VM for serving files
        local current_temp_serve_dir="${TEMP_SERVE_DIR_BASE}-${vm_id}"
        local vm_params_script_name="vm-${vm_id}-params.sh"

        # --- Installation Phase ---
        if [ -f "$disk_image_path" ]; then
            log "Disk image $disk_image_path already exists for VM $vm_name. Skipping installation phase."
        else
            log "=== Starting Installation Phase for VM $vm_name ==="
            log "Creating disk image for $vm_name ($disk_size_gb GB) at $disk_image_path..."
            if ! qemu-img create -f qcow2 "$disk_image_path" "${disk_size_gb}G"; then
                log "Error: Failed to create disk image for $vm_name. Skipping this VM."
                continue
            fi
            log "Disk image created successfully."

            log "Preparing temporary HTTP server content for $vm_name in $current_temp_serve_dir..."
            rm -rf "$current_temp_serve_dir" # Clean up previous attempt if any
            mkdir -p "${current_temp_serve_dir}/scripts"
            mkdir -p "${current_temp_serve_dir}/vpn"

            log "Creating VM-specific parameters script: ${current_temp_serve_dir}/${vm_params_script_name}"
            cat << EOF > "${current_temp_serve_dir}/${vm_params_script_name}"
#!/bin/sh
export HOST_IP="${HOST_IP_FOR_GUEST}"
export HTTP_PORT="${current_http_port}"
export VM_ID="${vm_id}"
export VNC_PASS="${vnc_password}"
export OVPN_CONF_FILENAME="${openvpn_config_file}"
EOF
            chmod +x "${current_temp_serve_dir}/${vm_params_script_name}"

            log "Copying guest setup script, VPN config (${openvpn_config_file}), and preseed file to temporary serve directory..."
            cp "${SCRIPTS_DIR}/${GUEST_SETUP_SCRIPT_NAME}" "${current_temp_serve_dir}/scripts/"
            cp "${VPN_CONFIG_DIR}/${openvpn_config_file}" "${current_temp_serve_dir}/vpn/"
            cp "$PRESEED_FILE" "$current_temp_serve_dir/"
            log "Temporary content prepared."

            log "Starting temporary HTTP server for $vm_name on port $current_http_port..."
            (cd "$current_temp_serve_dir" && python3 -m http.server "$current_http_port" &)
            http_server_pid=$!

            log "Waiting up to 10s for HTTP server (PID: $http_server_pid) to start..."
            local server_wait_time=0
            while ! ps -p $http_server_pid > /dev/null && [ "$server_wait_time" -lt 10 ]; do
                sleep 1
                server_wait_time=$((server_wait_time + 1))
            done

            if ! ps -p $http_server_pid > /dev/null; then
                log "Error: Failed to start or verify temporary HTTP server (PID: $http_server_pid) for $vm_name. Skipping this VM."
                rm -rf "$current_temp_serve_dir"
                continue
            fi
            log "Temporary HTTP server started successfully."

            log "Starting Ubuntu installation for $vm_name. This will take a while..."
            log "  VNC for installation: localhost:$vnc_port_host (Display ID :$((vnc_port_host - 5900)))"
            log "  Monitor QEMU output for progress or errors."

            local preseed_url="http://${HOST_IP_FOR_GUEST}:${current_http_port}/preseed.cfg"
            local params_url="http://${HOST_IP_FOR_GUEST}:${current_http_port}/${vm_params_script_name}"
            local vnc_display_id=$((vnc_port_host - 5900))

            local qemu_install_cmd=(
                qemu-system-x86_64
                -enable-kvm
                -m "${ram_mb}M"
                -smp 1
                -cpu "$cpu_model"
                -uuid "$vm_uuid"
                -smbios "type=1,serial=${bios_serial}"
                -drive "file=${disk_image_path},format=qcow2,if=virtio"
                -cdrom "$ISO_PATH"
                -boot d
                -netdev "user,id=net0,hostfwd=tcp::${vnc_port_host}-:5900"
                -device "virtio-net-pci,netdev=net0,mac=${mac_address}"
                -vnc ":${vnc_display_id}"
                -k en-us
                -machine q35,accel=kvm
                -serial mon:stdio  # Send serial output to stdio for logging by this script
                -display none      # Do not open a QEMU window, rely on VNC
                -append "auto=true priority=critical quiet splash --- preseed/url=${preseed_url} vm_setup_params_url=${params_url} DEBCONF_DEBUG=5"
            )

            log "Executing QEMU for installation: ${qemu_install_cmd[*]}"
            # Execute and capture exit code
            # Since `set -e` is active, script would exit if QEMU fails.
            # To capture exit code explicitly:
            set +e # Temporarily disable exit on error to capture code
            "${qemu_install_cmd[@]}"
            qemu_exit_code=$?
            set -e # Re-enable exit on error

            if [ $qemu_exit_code -ne 0 ]; then
                log "Error: QEMU installation process for $vm_name exited with code $qemu_exit_code."
                log "  The installation may have failed. Check VNC console during install or mount disk image to check logs (e.g., /target/var/log/late_command.log in the image)."
                log "  Skipping further setup for $vm_name."
                # Cleanup HTTP server
                log "Stopping temporary HTTP server for $vm_name (PID: $http_server_pid)..."
                kill "$http_server_pid" || log "Warning: Failed to kill HTTP server PID $http_server_pid. It might have already exited."
                wait "$http_server_pid" 2>/dev/null || true
                rm -rf "$current_temp_serve_dir"
                log "Temporary HTTP server stopped and files cleaned up."
                continue # Skip to the next VM
            fi
            log "Installation for $vm_name finished successfully (QEMU process exited with code 0)."

            log "Stopping temporary HTTP server for $vm_name (PID: $http_server_pid)..."
            kill "$http_server_pid" || log "Warning: Failed to kill HTTP server PID $http_server_pid. It might have already exited."
            wait "$http_server_pid" 2>/dev/null || true
            rm -rf "$current_temp_serve_dir"
            log "Temporary HTTP server stopped and files cleaned up."
            log "=== Installation Phase for VM $vm_name Completed ==="
        fi # End of installation block

        # --- Normal Boot and CPU Limit ---
        log "=== Starting Normal Boot for VM $vm_name ==="
        local vnc_display_id_normal=$((vnc_port_host - 5900)) # VNC display ID for normal boot

        # QEMU command for normal boot (daemonized)
        # Note: -daemonize makes QEMU run in the background.
        # We need its PID to apply cpulimit.
        # A common way is to use -pidfile option.
        local pid_file="/tmp/${vm_name}.pid"
        rm -f "$pid_file" # Ensure it's clean before starting

        qemu-system-x86_64 \
            -enable-kvm \
            -m "${ram_mb}M" \
            -smp 1 \
            -cpu "$cpu_model" \
            -uuid "$vm_uuid" \
            -smbios type=1,serial="$bios_serial" \
            -drive "file=${disk_image_path},format=qcow2,if=virtio" \
            -boot c \
            -netdev "user,id=net0,hostfwd=tcp::${vnc_port_host}-:5900" \
            -device "virtio-net-pci,netdev=net0,mac=${mac_address}" \
            -vnc ":${vnc_display_id_normal},password" \
            -k en-us \
            -machine q35,accel=kvm \
            -monitor "telnet::${vnc_port_host//59/44}1,server,nowait" \
            -qmp "tcp:localhost:${vnc_port_host//59/45}1,server,nowait" \
            -pidfile "$pid_file" \
            -daemonize
            # For VNC password: QEMU monitor command `change vnc password YOUR_PASSWORD`
            # This can be scripted via QMP or monitor. For simplicity, the guest sets its own VNC via x11vnc.
            # The -vnc option with ",password" means it will prompt on first client connection if no password set via monitor.
            # Since x11vnc inside the guest manages its own password, this QEMU-level VNC password is less critical here,
            # but good for initial connection before guest's x11vnc is up.
            # We are relying on x11vnc on port 5900 *inside* the guest, forwarded by hostfwd.

        log "VM $vm_name daemonizing. Waiting up to 30s for PID file $pid_file..."
        local wait_time=0
        while [ ! -s "$pid_file" ] && [ "$wait_time" -lt 30 ]; do # -s checks if file exists and is not empty
            sleep 1
            wait_time=$((wait_time + 1))
            if [ $((wait_time % 5)) -eq 0 ]; then
                log "Still waiting for PID file $pid_file for $vm_name... ($wait_time s)"
            fi
        done

        if [ ! -s "$pid_file" ]; then # Check again if file exists and is not empty
            log "Error: PID file $pid_file for $vm_name not found or empty after 30 seconds. VM may have failed to daemonize properly."
            log "  Check QEMU logs or console output if any was captured."
            continue # Skip to next VM
        fi

        local qemu_pid
        qemu_pid=$(cat "$pid_file")
        if ! [[ "$qemu_pid" =~ ^[0-9]+$ ]]; then # Check if PID is a number
            log "Error: Content of PID file $pid_file ('$qemu_pid') is not a valid PID for $vm_name. VM startup likely failed."
            rm -f "$pid_file"
            continue
        fi

        if ! ps -p "$qemu_pid" > /dev/null; then
            log "Error: QEMU process $qemu_pid for $vm_name (read from PID file) is not running. VM startup likely failed shortly after launch."
            log "  Check for QEMU errors if any were logged to console or system logs."
            rm -f "$pid_file"
            continue
        fi
        log "VM $vm_name running with PID $qemu_pid."

        log "Applying CPU limit (target 80% of 1 core) to PID $qemu_pid for $vm_name..."
        # cpulimit expects percentage of a single core.
        # The request is "800MHz (approximately 80% of a single core)".
        # Interpreting as "limit to using 80% of one CPU core's capacity".
        if ! cpulimit -p "$qemu_pid" -l 80 -b; then
            log "Warning: cpulimit command failed for $vm_name (PID $qemu_pid)."
            log "  This may be due to insufficient permissions (try running script with sudo if not already) or if the process $qemu_pid died."
            log "  CPU limiting for $vm_name may not be active."
        else
            log "cpulimit applied successfully to $vm_name (PID $qemu_pid)."
        fi
        # The -b flag runs cpulimit in the background.

        log "VM $vm_name setup on host is complete. Details logged."
        log "  Name: $vm_name, MAC: $mac_address, Host VNC Port: $vnc_port_host, In-Guest VNC Pass: ${vnc_password}, UUID: $vm_uuid, BIOS Serial: $bios_serial, PID: $qemu_pid"

        # Append to vm_info.txt
        echo "${vm_name},${mac_address},${vnc_port_host},${vnc_password},${vm_uuid},${bios_serial}" >> "$VM_INFO_FILE"
        log "VM details appended to $VM_INFO_FILE"
        log "=== Normal Boot for VM $vm_name Completed ==="
        log "--- Finished processing for VM $vm_name ---"

    done

    log "All VM processing finished. Check $VM_INFO_FILE for summary."
    log "VM information saved in $VM_INFO_FILE"
    log "You may need to wait a few minutes for VMs to fully boot and for guest setup scripts to complete (OpenVPN, Telegram install)."
    log "Access VMs via VNC clients (e.g., TigerVNC, Remmina) connecting to localhost:PORT (e.g., localhost:5900, localhost:5901, ...)."
}

# Trap for cleanup (e.g., stop HTTP server if script exits prematurely)
# This is tricky with backgrounded http server per VM.
# For now, manual cleanup of http server or /tmp files might be needed if script fails mid-operation.
# A more robust solution would track all PIDs and kill them on exit.

# Run main function
main

exit 0
EOF
